import B.Reasoning.SimplifierCorrect.Lemmas

open Classical B PHOAS ZFSet

set_option maxHeartbeats 300000 in
theorem simplifier_partial_correct.mul.var.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  (typ_y : Œì ‚ä¢ y : BType.int) {X Y : ZFSet.{u_1}}
  {hTœÑ : X *·∂ª Y ‚àà BType.int.toZFSet} {v : ùí±}
  (ht : ‚àÄ v_1 ‚àà fv (B.Term.var v *·¥Æ y), (¬´Œî¬ª v_1).isSome = true) (wf_t : (B.Term.var v *·¥Æ y).WF)
  (typ_t : Œì ‚ä¢ B.Term.var v *·¥Æ y : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶(B.Term.var v).abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©)
  {x_pf : ‚àÄ v_1 ‚àà fv (simplifier (B.Term.var v)), (¬´Œî¬ª v_1).isSome = true}
  (x_ih : ‚ü¶(simplifier (B.Term.var v)).abstract ¬´Œî¬ª x_pf‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©)
  {y_pf : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª y_pf‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©) :
  ‚ü¶(simplifier (B.Term.var v *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ =
    some ‚ü®X *·∂ª Y, ‚ü®BType.int, hTœÑ‚ü©‚ü© := by
  cases y with
  | var v' =>
    unfold simplifier simplifier_aux_mul
    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, Option.some_inj] at x_ih y_ih ‚ä¢
    rw [x_ih, y_ih]
  | int n =>
    unfold simplifier simplifier_aux_mul
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at den_x den_y
    by_cases hn : n = 0
    ¬∑ subst n
      injection den_y
      subst Y
      simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj]
      symm
      congr
      ¬∑ exact overloadBinOp_Int.mul_zero
      ¬∑ funext
        rw [overloadBinOp_Int.mul_zero]
      ¬∑ apply proof_irrel_heq
    ¬∑ by_cases hn : n = 1
      ¬∑ subst n
        injection den_y
        subst Y
        simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj, den_x]
        symm
        congr
        ¬∑ exact overloadBinOp_Int.mul_one
        ¬∑ funext
          rw [overloadBinOp_Int.mul_one]
        ¬∑ apply proof_irrel_heq
      ¬∑ simp_rw [simplifier]
        conv =>
          enter [1,1,1]
          change ?_match
        have : ?_match = .var v *·¥Æ .int n := by
          split <;> (injections; try first | contradiction | rfl)
        simp_rw [this]
        injection den_y
        subst Y
        simp_rw [Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, den_x]
  | bool
  | maplet
  | le
  | and
  | not
  | eq
  | ¬´‚Ñ§¬ª
  | ùîπ
  | mem
  | collect
  | pow
  | cprod
  | union
  | inter
  | lambda
  | pfun
  | all =>
    nomatch typ_y
  | add a b =>
    unfold simplifier simplifier_aux_mul
    obtain ‚ü®-, typ_a, typ_b‚ü© := Typing.addE typ_y

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih

    by_cases h_simp_add_a_b_eq_0 : simplifier (a +·¥Æ b) = .int 0
    ¬∑ simp_rw [h_simp_add_a_b_eq_0, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
      injection y_ih with eq
      simp_rw [h_simp_add_a_b_eq_0, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj]
      congr
      ¬∑ rw [‚Üêeq, overloadBinOp_Int.mul_zero]
      ¬∑ funext
        rw [‚Üêeq, overloadBinOp_Int.mul_zero]
      ¬∑ apply proof_irrel_heq
    ¬∑ by_cases h_simp_add_a_b_eq_1 : simplifier (a +·¥Æ b) = .int 1
      ¬∑ simp_rw [h_simp_add_a_b_eq_1, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
        injection y_ih with eq
        simp_rw [h_simp_add_a_b_eq_1, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj]
        rw [x_ih]
        congr
        ¬∑ rw [‚Üêeq, overloadBinOp_Int.mul_one]
        ¬∑ funext
          rw [‚Üêeq, overloadBinOp_Int.mul_one]
        ¬∑ apply proof_irrel_heq
      ¬∑ conv =>
          enter [1,1,1]
          conv => arg 2; unfold simplifier
        simp_rw [Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]
  | sub a b =>
    unfold simplifier simplifier_aux_mul
    obtain ‚ü®-, typ_a, typ_b‚ü© := Typing.subE typ_y

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih y_ih

    obtain ‚ü®A, œÑA, hX, den_a, eq‚ü© := y_ih
    obtain ‚ü®‚ü© := denote_welltyped_eq
      ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
      WFTC.of_abstract, _,
      Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; left; exact fv_simplifier wf_t.2.1 hv) (B.Typing.simplifier typ_a)‚ü©
      den_a
    simp_rw [Option.bind_eq_some_iff, PSigma.exists] at eq
    obtain ‚ü®B, œÑB, hY, den_b, eq‚ü© := eq
    obtain ‚ü®‚ü© := denote_welltyped_eq
      ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
      WFTC.of_abstract, _,
      Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; right; exact (fv_simplifier wf_t.2.2 hv)) (Typing.simplifier typ_b)‚ü©
      den_b
    rw [Option.some_inj] at eq
    injection eq with eq

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, x_ih, den_a, Option.bind_some, den_b, Option.bind_some, Option.some_inj]
    congr 1
    ¬∑ rw [eq]
    ¬∑ congr 1
      ¬∑ funext
        rw [eq]
      ¬∑ apply proof_irrel_heq
  | mul a b =>
    unfold simplifier simplifier_aux_mul
    obtain ‚ü®-, typ_a, typ_b‚ü© := Typing.mulE typ_y

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih

    by_cases h_simp_mul_a_b_eq_0 : simplifier (a *·¥Æ b) = .int 0
    ¬∑ simp_rw [h_simp_mul_a_b_eq_0, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
      injection y_ih with eq
      simp_rw [h_simp_mul_a_b_eq_0, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj]
      congr
      ¬∑ rw [‚Üêeq, overloadBinOp_Int.mul_zero]
      ¬∑ funext
        rw [‚Üêeq, overloadBinOp_Int.mul_zero]
      ¬∑ apply proof_irrel_heq
    ¬∑ by_cases h_simp_mul_a_b_eq_1 : simplifier (a *·¥Æ b) = .int 1
      ¬∑ simp_rw [h_simp_mul_a_b_eq_1, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
        injection y_ih with eq
        simp_rw [h_simp_mul_a_b_eq_1, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj]
        rw [x_ih]
        congr
        ¬∑ rw [‚Üêeq, overloadBinOp_Int.mul_one]
        ¬∑ funext
          rw [‚Üêeq, overloadBinOp_Int.mul_one]
        ¬∑ apply proof_irrel_heq
      ¬∑ conv =>
          enter [1,1,1]
          conv => arg 2; unfold simplifier
        simp_rw [Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]
  | card S =>
    unfold simplifier simplifier_aux_mul
    obtain ‚ü®-, œÑS, typ_S‚ü© := Typing.cardE typ_y

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at y_ih

    obtain ‚ü®S', œÑS', hS', den_simpS, eq‚ü© := y_ih
    obtain ‚ü®‚ü© := denote_welltyped_eq
      ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
      WFTC.of_abstract, _,
      Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; exact fv_simplifier wf_t.2 hv) (Typing.simplifier typ_S)‚ü©
      den_simpS

    dsimp at eq
    split_ifs at eq with S'_fin
    rw [Option.some_inj] at eq
    injection eq with eq

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, x_ih, den_simpS, Option.bind_some, dite_cond_eq_true (eq_true S'_fin), Option.bind_some, Option.some_inj]
    congr 2
    ¬∑ funext
      rw [‚Üêeq]
      congr
    ¬∑ apply proof_irrel_heq
  | app f s =>
    unfold simplifier simplifier_aux_mul
    obtain ‚ü®Œ±, typ_f, typ_s‚ü© := Typing.appE typ_y

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at y_ih
    obtain ‚ü®simpF, œÑsimpF, hsimpF, den_simpF, eq‚ü© := y_ih

    obtain ‚ü®‚ü© := denote_welltyped_eq
      ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
      WFTC.of_abstract, _,
      Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; left; exact fv_simplifier wf_t.2.1 hv) (Typing.simplifier typ_f)‚ü©
      den_simpF

    simp_rw [Option.bind_eq_some_iff, PSigma.exists] at eq
    obtain ‚ü®simpS, œÑsimpS, hsimpS, den_simpS, eq‚ü© := eq
    obtain ‚ü®‚ü© := denote_welltyped_eq
      ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
      WFTC.of_abstract, _,
      Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; right; exact fv_simplifier wf_t.2.2 hv) (Typing.simplifier typ_s)‚ü©
      den_simpS
    simp_rw [dite_true] at eq
    split_ifs at eq with simpF_isfunc simpS_mem_simpF_dom
    rw [Option.some_inj] at eq
    injection eq with eq

    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, den_simpF, Option.bind_some, den_simpS, Option.bind_some, dite_true, dite_cond_eq_true (eq_true simpF_isfunc), dite_cond_eq_true (eq_true simpS_mem_simpF_dom), Option.bind_some, Option.some_inj]

    congr 1
    ¬∑ rw [eq]
    ¬∑ congr 1
      ¬∑ funext
        rw [eq]
      ¬∑ apply proof_irrel_heq
  | min S
  | max S =>
    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.some_inj, Option.bind_eq_some_iff, PSigma.exists] at x_ih y_ih

    first
    | obtain ‚ü®-, typ_S‚ü© := Typing.minE typ_y
    | obtain ‚ü®-, typ_S‚ü© := Typing.maxE typ_y

    obtain ‚ü®S', œÑS', hS', den_S', eq‚ü© := y_ih
    obtain ‚ü®‚ü© := denote_welltyped_eq
      ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
      WFTC.of_abstract, _,
      Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; exact fv_simplifier wf_t.2 hv) (Typing.simplifier typ_S)‚ü©
      den_S'
    dsimp at eq
    split_ifs at eq with S'_fin_nemp
    rw [Option.some_inj] at eq
    injection eq
    subst Y

    simp_rw [simplifier, simplifier_aux_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, den_S', Option.bind_some, dite_cond_eq_true (eq_true S'_fin_nemp), Option.bind_some]

set_option maxHeartbeats 300000 in
theorem simplifier_partial_correct.mul.int.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  (typ_y : Œì ‚ä¢ y : BType.int) {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {n : ‚Ñ§}
  (ht : ‚àÄ v ‚àà fv (B.Term.int n *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : (B.Term.int n *·¥Æ y).WF)
  (typ_t : Œì ‚ä¢ B.Term.int n *·¥Æ y : BType.int) (typ_x : Œì ‚ä¢ B.Term.int n : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶(B.Term.int n).abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª ht‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©)
  {x_pf : ‚àÄ v ‚àà fv (simplifier (B.Term.int n)), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier (B.Term.int n)).abstract ¬´Œî¬ª x_pf‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©)
  {y_pf : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª y_pf‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©) :
  ‚ü¶(simplifier (B.Term.int n *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ =
  some ‚ü®overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y, ‚ü®BType.int, hTœÑ‚ü©‚ü© := by
  unfold simplifier
  simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
  injection x_ih
  subst X

  by_cases n_eq_0 : n = 0
  ¬∑ unfold simplifier_aux_mul
    subst n
    simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at ‚ä¢

    congr
    ¬∑ rw [overloadBinOp_Int.zero_mul]
    ¬∑ rw [overloadBinOp_Int.zero_mul]
    ¬∑ apply proof_irrel_heq
  ¬∑ by_cases n_eq_1 : n = 1
    ¬∑ unfold simplifier_aux_mul
      subst n
      cases y with
      | bool
      | maplet
      | le
      | and
      | not
      | eq
      | ¬´‚Ñ§¬ª
      | ùîπ
      | mem
      | collect
      | pow
      | cprod
      | union
      | inter
      | lambda
      | pfun
      | all =>
        nomatch typ_y
      | int m =>
        by_cases m_eq_0 : m = 0
        ¬∑ subst m
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at den_y
          injection den_y
          subst Y

          simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases m_eq_1 : m = 1
          ¬∑ subst m
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at den_y
            injection den_y
            subst Y

            simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ simp only [simplifier, B.Term.int.injEq, m_eq_0, imp_self]
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at den_y
            injection den_y
            subst Y
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
      | var v =>
        simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj, den_y] at den_y ‚ä¢
        congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
      | add a b =>
        by_cases add_a_b_eq_0 : simplifier (a +·¥Æ b) = .int 0
        ¬∑ simp_rw [add_a_b_eq_0, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih ‚ä¢
          injection y_ih
          subst Y
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases add_a_b_eq_1 : simplifier (a +·¥Æ b) = .int 1
          ¬∑ simp_rw [add_a_b_eq_1, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih ‚ä¢
            injection y_ih
            subst Y
            congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
          ¬∑ unfold simplifier at add_a_b_eq_0 add_a_b_eq_1 y_ih ‚ä¢
            simp only
            simp_rw [y_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
      | sub a b =>
        by_cases sub_a_b_eq_0 : simplifier (a -·¥Æ b) = .int 0
        ¬∑ simp_rw [sub_a_b_eq_0, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih ‚ä¢
          injection y_ih
          subst Y
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases sub_a_b_eq_1 : simplifier (a -·¥Æ b) = .int 1
          ¬∑ simp_rw [sub_a_b_eq_1, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih ‚ä¢
            injection y_ih
            subst Y
            congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
          ¬∑ unfold simplifier at sub_a_b_eq_0 sub_a_b_eq_1 y_ih ‚ä¢
            simp only
            simp_rw [y_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
      | mul a b =>
        by_cases mul_a_b_eq_0 : simplifier (a *·¥Æ b) = .int 0
        ¬∑ simp_rw [mul_a_b_eq_0, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih ‚ä¢
          injection y_ih
          subst Y
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases mul_a_b_eq_1 : simplifier (a *·¥Æ b) = .int 1
          ¬∑ simp_rw [mul_a_b_eq_1, simplifier, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih ‚ä¢
            injection y_ih
            subst Y
            congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
          ¬∑ unfold simplifier at mul_a_b_eq_0 mul_a_b_eq_1 y_ih ‚ä¢
            simp only
            simp_rw [y_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
      | card S =>
        obtain ‚ü®-, _, typ_S‚ü© := Typing.cardE typ_y
        simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at y_ih
        obtain ‚ü®simpS, _, hsimpS, den_simpS, eq‚ü© := y_ih
        obtain ‚ü®‚ü© := denote_welltyped_eq
          ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
          WFTC.of_abstract, _,
          Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; exact fv_simplifier wf_t.2 hv) (Typing.simplifier typ_S)‚ü©
          den_simpS
        dsimp at eq
        split_ifs at eq with simpS_fin
        rw [Option.some_inj] at eq
        injection eq
        subst Y

        simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_simpS, Option.bind_some, dite_cond_eq_true (eq_true simpS_fin), Option.some_inj]

        congr 1
        ¬∑ rw [overloadBinOp_Int.one_mul]
          rfl
        ¬∑ congr
          ¬∑ funext
            rw [overloadBinOp_Int.one_mul]
            rfl
          ¬∑ apply proof_irrel_heq
      | app f s =>
        obtain ‚ü®_, typ_f, typ_s‚ü© := Typing.appE typ_y
        simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at y_ih
        obtain ‚ü®F, _, hF, den_f, eq‚ü© := y_ih
        obtain ‚ü®‚ü© := denote_welltyped_eq
          ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
          WFTC.of_abstract, _,
          Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; left; exact fv_simplifier wf_t.2.1 hv) (Typing.simplifier typ_f)‚ü©
          den_f

        simp_rw [Option.bind_eq_some_iff, PSigma.exists] at eq
        obtain ‚ü®S, _, hS, den_s, eq‚ü© := eq
        obtain ‚ü®‚ü© := denote_welltyped_eq
          ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
          WFTC.of_abstract, _,
          Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; right; exact fv_simplifier wf_t.2.2 hv) (Typing.simplifier typ_s)‚ü©
          den_s
        simp only [dite_true] at eq
        split_ifs at eq with F_isfunc S_mem_Fdom
        rw [Option.some_inj] at eq
        injection eq
        subst Y

        simp_rw [simplifier, Term.abstract, denote, Option.bind_eq_bind, Option.pure_def, den_f, Option.bind_some, den_s, Option.bind_some, dite_true, dite_cond_eq_true (eq_true F_isfunc), dite_cond_eq_true (eq_true S_mem_Fdom), Option.some_inj]

        congr 1
        ¬∑ rw [overloadBinOp_Int.one_mul]
        ¬∑ congr 1
          ¬∑ rw [overloadBinOp_Int.one_mul]
          ¬∑ apply proof_irrel_heq
      | min S
      | max S =>
        first
        | obtain ‚ü®-, typ_S‚ü© := Typing.minE typ_y
        | obtain ‚ü®-, typ_S‚ü© := Typing.maxE typ_y
        simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at y_ih
        obtain ‚ü®S', œÑS', hS', den_S, eq‚ü© := y_ih
        obtain ‚ü®‚ü© := denote_welltyped_eq
          ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
          WFTC.of_abstract, _,
          Typing.of_abstract (fun v hv => by apply ht; simp_rw [fv, List.mem_append]; right; exact fv_simplifier wf_t.2 hv) (Typing.simplifier typ_S)‚ü©
          den_S
        dsimp at eq
        split_ifs at eq with S'_fin_nemp
        rw [Option.some_inj] at eq
        injection eq
        subst Y

        simp_rw [simplifier, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_S, Option.bind_some, dite_cond_eq_true (eq_true S'_fin_nemp), Option.some_inj]
        congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases simpy_0 : simplifier y = .int 0
      ¬∑ simp_rw [simpy_0, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
        injection y_ih
        subst Y

        simp [simplifier, simpy_0]
        have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
          unfold simplifier_aux_mul
          split <;>
          ¬∑ injections
            first
            | rfl
            | contradiction
            | (try subst_eqs; contradiction)
        simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
        congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
      ¬∑ by_cases simpy_1 : simplifier y = .int 1
        ¬∑ simp_rw [simpy_1, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier, simpy_1]
          have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
            unfold simplifier_aux_mul
            split <;>
            ¬∑ injections
              first
              | rfl
              | contradiction
              | (try subst_eqs; contradiction)
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
        ¬∑ by_cases simpy_int : ‚àÉ m, simplifier y = .int m
          ¬∑ obtain ‚ü®m, simpy_int‚ü© := simpy_int

            simp_rw [simpy_int, Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            simp_rw [simpy_int, simplifier]
            have : simplifier_aux_mul (B.Term.int n) (B.Term.int m) = .int (n * m) := by
              unfold simplifier_aux_mul
              split using _ | _ | _ | _ | _ | _ | contr _  <;> injections
              iterate 5
                ¬∑ injections
                  subst_vars
                  first
                  | contradiction
                  | rfl
              ¬∑ nomatch contr n m rfl rfl
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
          ¬∑ simp_rw [simplifier]
            have : simplifier_aux_mul (B.Term.int n) (simplifier y) = .int n *·¥Æ (simplifier y) := by
              unfold simplifier_aux_mul
              split using _ | _ | _ | _ | contr <;> (injections; try contradiction)
              ¬∑ push_neg at simpy_int
                nomatch simpy_int _ contr
              ¬∑ rfl
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]

set_option maxHeartbeats 600000 in
theorem simplifier_partial_correct.mul.add.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {a b : B.Term}
  (ht : ‚àÄ v ‚àà fv ((a +·¥Æ b) *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : ((a +·¥Æ b) *·¥Æ y).WF)
  (typ_x : Œì ‚ä¢ a +·¥Æ b : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶(a +·¥Æ b).abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©)
  {pf : ‚àÄ v ‚àà fv (simplifier (a +·¥Æ b)), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier (a +·¥Æ b)).abstract ¬´Œî¬ª pf‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©)
  {pf_1 : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª pf_1‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©) :
  ‚ü¶(simplifier ((a +·¥Æ b) *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ =
    some ‚ü®overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y, ‚ü®BType.int, hTœÑ‚ü©‚ü© := by
  unfold simplifier
  by_cases eq0 : simplifier (a +·¥Æ b) = .int 0
  ¬∑ simp_rw [eq0] at x_ih ‚ä¢
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    injection x_ih
    subst X

    simp [simplifier_aux_mul]
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
    congr <;> first | rw [overloadBinOp_Int.zero_mul] | apply proof_irrel_heq
  ¬∑ by_cases eq1 : simplifier (a +·¥Æ b) = .int 1
    ¬∑ simp_rw [eq1] at x_ih ‚ä¢
      simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
      injection x_ih
      subst X

      have : simplifier_aux_mul (B.Term.int 1) (simplifier y) = simplifier y := by
        unfold simplifier_aux_mul
        split <;> (injections; try contradiction)
        ¬∑ symm; assumption
        ¬∑ rfl
        ¬∑ subst_vars
          contradiction
      simp_rw [this, y_ih, Option.some_inj]
      congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases eq_int : ‚àÉ n, simplifier (a +·¥Æ b) = .int n
      ¬∑ obtain ‚ü®n,  eq_int‚ü© := eq_int
        simp_rw [eq_int] at x_ih ‚ä¢
        simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
        injection x_ih
        subst X

        by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y
          have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
            unfold simplifier_aux_mul
            split <;> (injections; try first | contradiction | rfl)
            ¬∑ injections
              subst_vars
              contradiction
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | (injections; subst_vars; contradiction) | rfl)
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              have : simplifier_aux_mul (.int n) (.int m) = .int (n * m) := by
                unfold simplifier_aux_mul
                rw [eq_int, B.Term.int.injEq] at eq0 eq1
                rename_i eq0' eq1' eq_int' _ _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                simp only
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
              congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
            ¬∑ push_neg at eq_int
              have : simplifier_aux_mul (.int n) (simplifier y) = .int n *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                rename_i eq0' eq1' eq_int' _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                split <;> (injections; try first | contradiction | rfl)
                ¬∑ nomatch eq_int _ ‚Äπ_‚Ä∫
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]
      ¬∑ by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier_aux_mul]
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (simplifier (a +·¥Æ b)) (.int 1) = simplifier (a +·¥Æ b) := by
              unfold simplifier_aux_mul
              split <;> (injections; try contradiction)
              ¬∑ rfl
              ¬∑ subst_vars
                contradiction
              ¬∑ subst_vars
                contradiction
            simp_rw [this, x_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              by_cases eq_mul : ‚àÉ u k, simplifier (a +·¥Æ b) = u *·¥Æ .int k
              ¬∑ obtain ‚ü®u, k, eq_mul‚ü© := eq_mul
                have typ_ := eq_mul ‚ñ∏ Typing.simplifier typ_x
                obtain ‚ü®-, typ_u, -‚ü© := Typing.mulE typ_
                simp_rw [eq_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih
                obtain ‚ü®U, _, hU, den_u, eq‚ü© := x_ih
                obtain ‚ü®‚ü© := denote_welltyped_eq
                  ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
                  WFTC.of_abstract, _,
                  Typing.of_abstract (fun v hv => by
                    have : v ‚àà fv (simplifier (a +·¥Æ b)) := by
                      rw [eq_mul, fv, List.mem_append]
                      left
                      exact hv
                    apply ht
                    rw [fv, List.mem_append]
                    left
                    exact fv_simplifier wf_t.1 this
                  ) typ_u‚ü©
                  den_u

                dsimp at eq
                rw [Option.some_inj] at eq
                injection eq
                subst X

                have : simplifier_aux_mul (simplifier (a +·¥Æ b)) (.int m) = u *·¥Æ .int (k * m) := by
                  rw [eq_mul, simplifier_aux_mul] <;>
                  ¬∑ rintro rfl
                    contradiction
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_u, Option.bind_some, Option.some_inj]
                congr 1
                ¬∑ conv =>
                    enter [1,3]
                    apply overloadBinOp_Int.const_folding.mul k m
                  rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                ¬∑ congr 1
                  ¬∑ funext
                    conv =>
                      enter [1,2,3]
                      apply overloadBinOp_Int.const_folding.mul k m
                    rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                  ¬∑ apply proof_irrel_heq
              ¬∑ push_neg at eq_mul
                have : simplifier_aux_mul (simplifier (a +·¥Æ b)) (B.Term.int m) = simplifier (a +·¥Æ b) *·¥Æ .int m := by
                  unfold simplifier_aux_mul
                  split <;> (injections; try first | contradiction | (subst_vars; contradiction))
                  ¬∑ rename simplifier (a +·¥Æ b) = _ => contr
                    rename ¬¨‚àÉ_, _ = _ => ne_int
                    push_neg at ne_int
                    nomatch ne_int _ contr
                  ¬∑ nomatch eq_mul _ _ ‚Äπ_‚Ä∫
                  ¬∑ rfl
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some]
            ¬∑ have : simplifier_aux_mul (simplifier (a +·¥Æ b)) (simplifier y) = simplifier (a +·¥Æ b) *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                split <;> try contradiction
                ¬∑ push_neg at eq_int
                  nomatch eq_int _ ‚Äπ_‚Ä∫
                ¬∑ push_neg at eq_int
                  nomatch eq_int _ ‚Äπ_‚Ä∫
                ¬∑ rfl
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]

theorem simplifier_partial_correct.mul.sub.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {a b : B.Term}
  (ht : ‚àÄ v ‚àà fv ((a -·¥Æ b) *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : ((a -·¥Æ b) *·¥Æ y).WF)
  (typ_x : Œì ‚ä¢ a -·¥Æ b : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶(a -·¥Æ b).abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©)
  {pf : ‚àÄ v ‚àà fv (simplifier (a -·¥Æ b)), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier (a -·¥Æ b)).abstract ¬´Œî¬ª pf‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©)
  {pf_1 : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª pf_1‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©) :
  ‚ü¶(simplifier ((a -·¥Æ b) *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ =
  some ‚ü®overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y, BType.int, hTœÑ‚ü© := by
  unfold simplifier
  by_cases eq0 : simplifier (a -·¥Æ b) = .int 0
  ¬∑ simp_rw [eq0] at x_ih ‚ä¢
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    injection x_ih
    subst X

    simp [simplifier_aux_mul]
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
    congr <;> first | rw [overloadBinOp_Int.zero_mul] | apply proof_irrel_heq
  ¬∑ by_cases eq1 : simplifier (a -·¥Æ b) = .int 1
    ¬∑ simp_rw [eq1] at x_ih ‚ä¢
      simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
      injection x_ih
      subst X

      have : simplifier_aux_mul (B.Term.int 1) (simplifier y) = simplifier y := by
        unfold simplifier_aux_mul
        split <;> injections
      simp_rw [this, y_ih, Option.some_inj]
      congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases eq_int : ‚àÉ n, simplifier (a -·¥Æ b) = .int n
      ¬∑ obtain ‚ü®n,  eq_int‚ü© := eq_int
        simp_rw [eq_int] at x_ih ‚ä¢
        simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
        injection x_ih
        subst X

        by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y
          have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
            unfold simplifier_aux_mul
            split <;> injections
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
              unfold simplifier_aux_mul
              split <;> injections
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              have : simplifier_aux_mul (.int n) (.int m) = .int (n * m) := by
                unfold simplifier_aux_mul
                rw [eq_int, B.Term.int.injEq] at eq0 eq1
                rename_i eq0' eq1' eq_int' _ _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                simp only
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
              congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
            ¬∑ push_neg at eq_int
              have : simplifier_aux_mul (.int n) (simplifier y) = .int n *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                rename_i eq0' eq1' eq_int' _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                split <;> injections
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]
      ¬∑ by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier_aux_mul]
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (simplifier (a -·¥Æ b)) (.int 1) = simplifier (a -·¥Æ b) := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | rfl)
            simp_rw [this, x_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              by_cases eq_mul : ‚àÉ u k, simplifier (a -·¥Æ b) = u *·¥Æ .int k
              ¬∑ obtain ‚ü®u, k, eq_mul‚ü© := eq_mul
                have typ_ := eq_mul ‚ñ∏ Typing.simplifier typ_x
                obtain ‚ü®-, typ_u, -‚ü© := Typing.mulE typ_
                simp_rw [eq_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih
                obtain ‚ü®U, _, hU, den_u, eq‚ü© := x_ih
                obtain ‚ü®‚ü© := denote_welltyped_eq
                  ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
                  WFTC.of_abstract, _,
                  Typing.of_abstract (fun v hv => by
                    have : v ‚àà fv (simplifier (a -·¥Æ b)) := by
                      rw [eq_mul, fv, List.mem_append]
                      left
                      exact hv
                    apply ht
                    rw [fv, List.mem_append]
                    left
                    exact fv_simplifier wf_t.1 this
                  ) typ_u‚ü©
                  den_u

                dsimp at eq
                rw [Option.some_inj] at eq
                injection eq
                subst X

                have : simplifier_aux_mul (simplifier (a -·¥Æ b)) (.int m) = u *·¥Æ .int (k * m) := by
                  rw [eq_mul, simplifier_aux_mul] <;>
                  ¬∑ rintro rfl
                    contradiction
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_u, Option.bind_some, Option.some_inj]
                congr 1
                ¬∑ conv =>
                    enter [1,3]
                    apply overloadBinOp_Int.const_folding.mul k m
                  rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                ¬∑ congr 1
                  ¬∑ funext
                    conv =>
                      enter [1,2,3]
                      apply overloadBinOp_Int.const_folding.mul k m
                    rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                  ¬∑ apply proof_irrel_heq
              ¬∑ push_neg at eq_mul
                have : simplifier_aux_mul (simplifier (a -·¥Æ b)) (B.Term.int m) = simplifier (a -·¥Æ b) *·¥Æ .int m := by
                  unfold simplifier_aux_mul
                  split <;> (injections; try first | contradiction | (subst_vars; contradiction) | rfl)
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some]
            ¬∑ have : simplifier_aux_mul (simplifier (a -·¥Æ b)) (simplifier y) = simplifier (a -·¥Æ b) *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                split <;> (injections; try first | contradiction | rfl)
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]

set_option maxHeartbeats 400000 in
theorem simplifier_partial_correct.mul.mul.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {a b : B.Term}
  (ht : ‚àÄ v ‚àà fv (a *·¥Æ b *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : (a *·¥Æ b *·¥Æ y).WF)
  (typ_x : Œì ‚ä¢ a *·¥Æ b : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶(a *·¥Æ b).abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©)
  {pf : ‚àÄ v ‚àà fv (simplifier (a *·¥Æ b)), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier (a *·¥Æ b)).abstract ¬´Œî¬ª pf‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©)
  {pf_1 : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª pf_1‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©) :
  ‚ü¶(simplifier (a *·¥Æ b *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ =
  some ‚ü®overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y, BType.int, hTœÑ‚ü© := by
  unfold simplifier
  by_cases eq0 : simplifier (a *·¥Æ b) = .int 0
  ¬∑ simp_rw [eq0] at x_ih ‚ä¢
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    injection x_ih
    subst X

    simp [simplifier_aux_mul]
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
    congr <;> first | rw [overloadBinOp_Int.zero_mul] | apply proof_irrel_heq
  ¬∑ by_cases eq1 : simplifier (a *·¥Æ b) = .int 1
    ¬∑ simp_rw [eq1] at x_ih ‚ä¢
      simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
      injection x_ih
      subst X

      have : simplifier_aux_mul (B.Term.int 1) (simplifier y) = simplifier y := by
        unfold simplifier_aux_mul
        split <;> (injections; try contradiction)
        ¬∑ symm; assumption
        ¬∑ rfl
        ¬∑ subst_vars
          contradiction
      simp_rw [this, y_ih, Option.some_inj]
      congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases eq_int : ‚àÉ n, simplifier (a *·¥Æ b) = .int n
      ¬∑ obtain ‚ü®n,  eq_int‚ü© := eq_int
        simp_rw [eq_int] at x_ih ‚ä¢
        simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
        injection x_ih
        subst X

        by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y
          have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
            unfold simplifier_aux_mul
            split <;> (injections; try first | contradiction | rfl)
            ¬∑ injections
              subst_vars
              contradiction
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | rfl | symm; assumption)
              ¬∑ injections
                subst_vars
                contradiction
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              have : simplifier_aux_mul (.int n) (.int m) = .int (n * m) := by
                unfold simplifier_aux_mul
                rw [eq_int, B.Term.int.injEq] at eq0 eq1
                rename_i eq0' eq1' eq_int' _ _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                simp only
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
              congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
            ¬∑ push_neg at eq_int
              have : simplifier_aux_mul (.int n) (simplifier y) = .int n *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                rename_i eq0' eq1' eq_int' _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                split <;> (injections; try first | contradiction | rfl)
                ¬∑ subst_vars
                  nomatch eq_int _ ‚Äπ_‚Ä∫
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]
      ¬∑ by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier_aux_mul]
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (simplifier (a *·¥Æ b)) (.int 1) = simplifier (a *·¥Æ b) := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | rfl) <;>
              ¬∑ subst_vars
                contradiction
            simp_rw [this, x_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              by_cases eq_mul : ‚àÉ u k, simplifier (a *·¥Æ b) = u *·¥Æ .int k
              ¬∑ obtain ‚ü®u, k, eq_mul‚ü© := eq_mul
                have typ_ := eq_mul ‚ñ∏ Typing.simplifier typ_x
                obtain ‚ü®-, typ_u, -‚ü© := Typing.mulE typ_
                simp_rw [eq_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih
                obtain ‚ü®U, _, hU, den_u, eq‚ü© := x_ih
                obtain ‚ü®‚ü© := denote_welltyped_eq
                  ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
                  WFTC.of_abstract, _,
                  Typing.of_abstract (fun v hv => by
                    have : v ‚àà fv (simplifier (a *·¥Æ b)) := by
                      rw [eq_mul, fv, List.mem_append]
                      left
                      exact hv
                    apply ht
                    rw [fv, List.mem_append]
                    left
                    exact fv_simplifier wf_t.1 this
                  ) typ_u‚ü©
                  den_u

                dsimp at eq
                rw [Option.some_inj] at eq
                injection eq
                subst X

                have : simplifier_aux_mul (simplifier (a *·¥Æ b)) (.int m) = u *·¥Æ .int (k * m) := by
                  rw [eq_mul, simplifier_aux_mul] <;>
                  ¬∑ rintro rfl
                    contradiction
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_u, Option.bind_some, Option.some_inj]
                congr 1
                ¬∑ conv =>
                    enter [1,3]
                    apply overloadBinOp_Int.const_folding.mul k m
                  rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                ¬∑ congr 1
                  ¬∑ funext
                    conv =>
                      enter [1,2,3]
                      apply overloadBinOp_Int.const_folding.mul k m
                    rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                  ¬∑ apply proof_irrel_heq
              ¬∑ push_neg at eq_mul
                have : simplifier_aux_mul (simplifier (a *·¥Æ b)) (B.Term.int m) = simplifier (a *·¥Æ b) *·¥Æ .int m := by
                  unfold simplifier_aux_mul
                  split <;> (injections; try first | contradiction | (subst_vars; contradiction) | rfl)
                  ¬∑ subst_vars
                    rename ¬¨‚àÉ_, _ = _ => ne_int
                    push_neg at ne_int
                    nomatch ne_int _ ‚Äπ_‚Ä∫
                  ¬∑ nomatch eq_mul _ _ ‚Äπ_‚Ä∫
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some]
            ¬∑ have : simplifier_aux_mul (simplifier (a *·¥Æ b)) (simplifier y) = simplifier (a *·¥Æ b) *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                split <;> (try first | contradiction | rfl) <;>
                ¬∑ push_neg at eq_int
                  nomatch eq_int _ ‚Äπ_‚Ä∫
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]

theorem simplifier_partial_correct.mul.card.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {S : B.Term}
  (ht : ‚àÄ v ‚àà fv (|S|·¥Æ *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : (|S|·¥Æ *·¥Æ y).WF)
  (typ_x : Œì ‚ä¢ |S|·¥Æ : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶|S|·¥Æ.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©)
  {pf : ‚àÄ v ‚àà fv (simplifier (|S|·¥Æ)), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier (|S|·¥Æ)).abstract ¬´Œî¬ª pf‚üß·¥Æ = some ‚ü®X, ‚ü®BType.int, hX‚ü©‚ü©)
  {pf_1 : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª pf_1‚üß·¥Æ = some ‚ü®Y, ‚ü®BType.int, hY‚ü©‚ü©) :
  ‚ü¶(simplifier (|S|·¥Æ *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ = some ‚ü®X *·∂ª Y, BType.int, hTœÑ‚ü© := by
  unfold simplifier
  by_cases eq0 : simplifier (|S|·¥Æ) = .int 0
  ¬∑ simp_rw [eq0] at x_ih ‚ä¢
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    injection x_ih
    subst X

    simp [simplifier_aux_mul]
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
    congr <;> first | rw [overloadBinOp_Int.zero_mul] | apply proof_irrel_heq
  ¬∑ by_cases eq1 : simplifier (|S|·¥Æ) = .int 1
    ¬∑ simp_rw [eq1] at x_ih ‚ä¢
      simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
      injection x_ih
      subst X

      have : simplifier_aux_mul (B.Term.int 1) (simplifier y) = simplifier y := by
        unfold simplifier_aux_mul
        split <;> injections
      simp_rw [this, y_ih, Option.some_inj]
      congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases eq_int : ‚àÉ n, simplifier (|S|·¥Æ) = .int n
      ¬∑ obtain ‚ü®n,  eq_int‚ü© := eq_int
        simp_rw [eq_int] at x_ih ‚ä¢
        simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
        injection x_ih
        subst X

        by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y
          have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
            unfold simplifier_aux_mul
            split <;> injections
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
              unfold simplifier_aux_mul
              split <;> injections
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              have : simplifier_aux_mul (.int n) (.int m) = .int (n * m) := by
                unfold simplifier_aux_mul
                rw [eq_int, B.Term.int.injEq] at eq0 eq1
                rename_i eq0' eq1' eq_int' _ _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                simp only
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
              congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
            ¬∑ push_neg at eq_int
              have : simplifier_aux_mul (.int n) (simplifier y) = .int n *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                rename_i eq0' eq1' eq_int' _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                split <;> injections
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]
      ¬∑ by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier_aux_mul]
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (simplifier (|S|·¥Æ)) (.int 1) = simplifier (|S|·¥Æ) := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | rfl)
            simp_rw [this, x_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              by_cases eq_mul : ‚àÉ u k, simplifier (|S|·¥Æ) = u *·¥Æ .int k
              ¬∑ obtain ‚ü®u, k, eq_mul‚ü© := eq_mul
                have typ_ := eq_mul ‚ñ∏ Typing.simplifier typ_x
                obtain ‚ü®-, typ_u, -‚ü© := Typing.mulE typ_
                simp_rw [eq_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih
                obtain ‚ü®U, _, hU, den_u, eq‚ü© := x_ih
                obtain ‚ü®‚ü© := denote_welltyped_eq
                  ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
                  WFTC.of_abstract, _,
                  Typing.of_abstract (fun v hv => by
                    have : v ‚àà fv (simplifier (|S|·¥Æ)) := by
                      rw [eq_mul, fv, List.mem_append]
                      left
                      exact hv
                    apply ht
                    rw [fv, List.mem_append]
                    left
                    exact fv_simplifier wf_t.1 this
                  ) typ_u‚ü©
                  den_u

                dsimp at eq
                rw [Option.some_inj] at eq
                injection eq
                subst X

                have : simplifier_aux_mul (simplifier (|S|·¥Æ)) (.int m) = u *·¥Æ .int (k * m) := by
                  rw [eq_mul, simplifier_aux_mul] <;>
                  ¬∑ rintro rfl
                    contradiction
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_u, Option.bind_some, Option.some_inj]
                congr 1
                ¬∑ conv =>
                    enter [1,3]
                    apply overloadBinOp_Int.const_folding.mul k m
                  rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                ¬∑ congr 1
                  ¬∑ funext
                    conv =>
                      enter [1,2,3]
                      apply overloadBinOp_Int.const_folding.mul k m
                    rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                  ¬∑ apply proof_irrel_heq
              ¬∑ push_neg at eq_mul
                have : simplifier_aux_mul (simplifier (|S|·¥Æ)) (B.Term.int m) = simplifier (|S|·¥Æ) *·¥Æ .int m := by
                  unfold simplifier_aux_mul
                  split <;> (injections; try first | contradiction | (subst_vars; contradiction) | rfl)
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some]
            ¬∑ have : simplifier_aux_mul (simplifier (|S|·¥Æ)) (simplifier y) = simplifier (|S|·¥Æ) *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                split <;> (injections; try first | contradiction | rfl)
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]

theorem simplifier_partial_correct.mul.app.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {f x : B.Term}
  (ht : ‚àÄ v ‚àà fv ((@·¥Æf) x *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : ((@·¥Æf) x *·¥Æ y).WF)
  (typ_x : Œì ‚ä¢ (@·¥Æf) x : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶((@·¥Æf) x).abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©)
  {pf : ‚àÄ v ‚àà fv (simplifier ((@·¥Æf) x)), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier ((@·¥Æf) x)).abstract ¬´Œî¬ª pf‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©)
  {pf_1 : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª pf_1‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©) :
  ‚ü¶(simplifier ((@·¥Æf) x *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ = some ‚ü®X *·∂ª Y, BType.int, hTœÑ‚ü© := by
  unfold simplifier
  by_cases eq0 : simplifier (.app f x) = .int 0
  ¬∑ simp_rw [eq0] at x_ih ‚ä¢
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    injection x_ih
    subst X

    simp [simplifier_aux_mul]
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
    congr <;> first | rw [overloadBinOp_Int.zero_mul] | apply proof_irrel_heq
  ¬∑ by_cases eq1 : simplifier (.app f x) = .int 1
    ¬∑ simp_rw [eq1] at x_ih ‚ä¢
      simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
      injection x_ih
      subst X

      have : simplifier_aux_mul (B.Term.int 1) (simplifier y) = simplifier y := by
        unfold simplifier_aux_mul
        split <;> injections
      simp_rw [this, y_ih, Option.some_inj]
      congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases eq_int : ‚àÉ n, simplifier (.app f x) = .int n
      ¬∑ obtain ‚ü®n,  eq_int‚ü© := eq_int
        simp_rw [eq_int] at x_ih ‚ä¢
        simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
        injection x_ih
        subst X

        by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y
          have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
            unfold simplifier_aux_mul
            split <;> injections
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
              unfold simplifier_aux_mul
              split <;> injections
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              have : simplifier_aux_mul (.int n) (.int m) = .int (n * m) := by
                unfold simplifier_aux_mul
                rw [eq_int, B.Term.int.injEq] at eq0 eq1
                rename_i eq0' eq1' eq_int' _ _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                simp only
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
              congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
            ¬∑ push_neg at eq_int
              have : simplifier_aux_mul (.int n) (simplifier y) = .int n *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                rename_i eq0' eq1' eq_int' _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                split <;> injections
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]
      ¬∑ by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier_aux_mul]
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (simplifier (.app f x)) (.int 1) = simplifier (.app f x) := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | rfl)
            simp_rw [this, x_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              by_cases eq_mul : ‚àÉ u k, simplifier (.app f x) = u *·¥Æ .int k
              ¬∑ obtain ‚ü®u, k, eq_mul‚ü© := eq_mul
                have typ_ := eq_mul ‚ñ∏ Typing.simplifier typ_x
                obtain ‚ü®-, typ_u, -‚ü© := Typing.mulE typ_
                simp_rw [eq_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih
                obtain ‚ü®U, _, hU, den_u, eq‚ü© := x_ih
                obtain ‚ü®‚ü© := denote_welltyped_eq
                  ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
                  WFTC.of_abstract, _,
                  Typing.of_abstract (fun v hv => by
                    have : v ‚àà fv (simplifier (.app f x)) := by
                      rw [eq_mul, fv, List.mem_append]
                      left
                      exact hv
                    apply ht
                    rw [fv, List.mem_append]
                    left
                    exact fv_simplifier wf_t.1 this
                  ) typ_u‚ü©
                  den_u

                dsimp at eq
                rw [Option.some_inj] at eq
                injection eq
                subst X

                have : simplifier_aux_mul (simplifier (.app f x)) (.int m) = u *·¥Æ .int (k * m) := by
                  rw [eq_mul, simplifier_aux_mul] <;>
                  ¬∑ rintro rfl
                    contradiction
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_u, Option.bind_some, Option.some_inj]
                congr 1
                ¬∑ conv =>
                    enter [1,3]
                    apply overloadBinOp_Int.const_folding.mul k m
                  rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                ¬∑ congr 1
                  ¬∑ funext
                    conv =>
                      enter [1,2,3]
                      apply overloadBinOp_Int.const_folding.mul k m
                    rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                  ¬∑ apply proof_irrel_heq
              ¬∑ push_neg at eq_mul
                have : simplifier_aux_mul (simplifier (.app f x)) (B.Term.int m) = simplifier (.app f x) *·¥Æ .int m := by
                  unfold simplifier_aux_mul
                  split <;> (injections; try first | contradiction | (subst_vars; contradiction) | rfl)
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some]
            ¬∑ have : simplifier_aux_mul (simplifier (.app f x)) (simplifier y) = simplifier (.app f x) *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                split <;> (injections; try first | contradiction | rfl)
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]

theorem simplifier_partial_correct.mul.min.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {S : B.Term}
  (ht : ‚àÄ v ‚àà fv (S.min *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : (S.min *·¥Æ y).WF)
  (typ_x : Œì ‚ä¢ S.min : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶S.min.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©)
  {pf : ‚àÄ v ‚àà fv (simplifier S.min), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier S.min).abstract ¬´Œî¬ª pf‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©)
  {pf_1 : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª pf_1‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©) :
  ‚ü¶(simplifier (S.min *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ = some ‚ü®X *·∂ª Y, BType.int, hTœÑ‚ü© := by
  unfold simplifier
  by_cases eq0 : simplifier S.min = .int 0
  ¬∑ simp_rw [eq0] at x_ih ‚ä¢
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    injection x_ih
    subst X

    simp [simplifier_aux_mul]
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
    congr <;> first | rw [overloadBinOp_Int.zero_mul] | apply proof_irrel_heq
  ¬∑ by_cases eq1 : simplifier S.min = .int 1
    ¬∑ simp_rw [eq1] at x_ih ‚ä¢
      simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
      injection x_ih
      subst X

      have : simplifier_aux_mul (B.Term.int 1) (simplifier y) = simplifier y := by
        unfold simplifier_aux_mul
        split <;> injections
      simp_rw [this, y_ih, Option.some_inj]
      congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases eq_int : ‚àÉ n, simplifier S.min = .int n
      ¬∑ obtain ‚ü®n,  eq_int‚ü© := eq_int
        simp_rw [eq_int] at x_ih ‚ä¢
        simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
        injection x_ih
        subst X

        by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y
          have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
            unfold simplifier_aux_mul
            split <;> injections
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
              unfold simplifier_aux_mul
              split <;> injections
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              have : simplifier_aux_mul (.int n) (.int m) = .int (n * m) := by
                unfold simplifier_aux_mul
                rw [eq_int, B.Term.int.injEq] at eq0 eq1
                rename_i eq0' eq1' eq_int' _ _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                simp only
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
              congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
            ¬∑ push_neg at eq_int
              have : simplifier_aux_mul (.int n) (simplifier y) = .int n *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                rename_i eq0' eq1' eq_int' _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                split <;> injections
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]
      ¬∑ by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier_aux_mul]
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (simplifier S.min) (.int 1) = simplifier S.min := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | rfl)
            simp_rw [this, x_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              by_cases eq_mul : ‚àÉ u k, simplifier S.min = u *·¥Æ .int k
              ¬∑ obtain ‚ü®u, k, eq_mul‚ü© := eq_mul
                have typ_ := eq_mul ‚ñ∏ Typing.simplifier typ_x
                obtain ‚ü®-, typ_u, -‚ü© := Typing.mulE typ_
                simp_rw [eq_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih
                obtain ‚ü®U, _, hU, den_u, eq‚ü© := x_ih
                obtain ‚ü®‚ü© := denote_welltyped_eq
                  ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
                  WFTC.of_abstract, _,
                  Typing.of_abstract (fun v hv => by
                    have : v ‚àà fv (simplifier S.min) := by
                      rw [eq_mul, fv, List.mem_append]
                      left
                      exact hv
                    apply ht
                    rw [fv, List.mem_append]
                    left
                    exact fv_simplifier wf_t.1 this
                  ) typ_u‚ü©
                  den_u

                dsimp at eq
                rw [Option.some_inj] at eq
                injection eq
                subst X

                have : simplifier_aux_mul (simplifier S.min) (.int m) = u *·¥Æ .int (k * m) := by
                  rw [eq_mul, simplifier_aux_mul] <;>
                  ¬∑ rintro rfl
                    contradiction
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_u, Option.bind_some, Option.some_inj]
                congr 1
                ¬∑ conv =>
                    enter [1,3]
                    apply overloadBinOp_Int.const_folding.mul k m
                  rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                ¬∑ congr 1
                  ¬∑ funext
                    conv =>
                      enter [1,2,3]
                      apply overloadBinOp_Int.const_folding.mul k m
                    rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                  ¬∑ apply proof_irrel_heq
              ¬∑ push_neg at eq_mul
                have : simplifier_aux_mul (simplifier S.min) (B.Term.int m) = simplifier S.min *·¥Æ .int m := by
                  unfold simplifier_aux_mul
                  split <;> (injections; try first | contradiction | (subst_vars; contradiction) | rfl)
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some]
            ¬∑ have : simplifier_aux_mul (simplifier S.min) (simplifier y) = simplifier S.min *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                split <;> (injections; try first | contradiction | rfl)
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]

theorem simplifier_partial_correct.mul.max.{u_1} {y : B.Term} {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} {Œì : B.TypeContext}
  {X Y : ZFSet.{u_1}}
  {hTœÑ : overloadBinOp_Int (fun x1 x2 => x1 * x2) X Y ‚àà BType.int.toZFSet} {S : B.Term}
  (ht : ‚àÄ v ‚àà fv (S.max *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : (S.max *·¥Æ y).WF)
  (typ_x : Œì ‚ä¢ S.max : BType.int) (hX : X ‚àà BType.int.toZFSet)
  (den_x : ‚ü¶S.max.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; left; exact hv))‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©) (hY : Y ‚àà BType.int.toZFSet)
  (den_y : ‚ü¶y.abstract ¬´Œî¬ª (fun v hv => ht v (by rw [fv, List.mem_append]; right; exact hv))‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©)
  {pf : ‚àÄ v ‚àà fv (simplifier S.max), (¬´Œî¬ª v).isSome = true}
  (x_ih : ‚ü¶(simplifier S.max).abstract ¬´Œî¬ª pf‚üß·¥Æ = some ‚ü®X, BType.int, hX‚ü©)
  {pf_1 : ‚àÄ v ‚àà fv (simplifier y), (¬´Œî¬ª v).isSome = true}
  (y_ih : ‚ü¶(simplifier y).abstract ¬´Œî¬ª pf_1‚üß·¥Æ = some ‚ü®Y, BType.int, hY‚ü©) :
  ‚ü¶(simplifier (S.max *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ = some ‚ü®X *·∂ª Y, BType.int, hTœÑ‚ü© := by
  unfold simplifier
  by_cases eq0 : simplifier S.max = .int 0
  ¬∑ simp_rw [eq0] at x_ih ‚ä¢
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
    injection x_ih
    subst X

    simp [simplifier_aux_mul]
    simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
    congr <;> first | rw [overloadBinOp_Int.zero_mul] | apply proof_irrel_heq
  ¬∑ by_cases eq1 : simplifier S.max = .int 1
    ¬∑ simp_rw [eq1] at x_ih ‚ä¢
      simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
      injection x_ih
      subst X

      have : simplifier_aux_mul (B.Term.int 1) (simplifier y) = simplifier y := by
        unfold simplifier_aux_mul
        split <;> injections
      simp_rw [this, y_ih, Option.some_inj]
      congr <;> first | rw [overloadBinOp_Int.one_mul] | apply proof_irrel_heq
    ¬∑ by_cases eq_int : ‚àÉ n, simplifier S.max = .int n
      ¬∑ obtain ‚ü®n,  eq_int‚ü© := eq_int
        simp_rw [eq_int] at x_ih ‚ä¢
        simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at x_ih
        injection x_ih
        subst X

        by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y
          have : simplifier_aux_mul (.int n) (.int 0) = .int 0 := by
            unfold simplifier_aux_mul
            split <;> injections
          simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (.int n) (.int 1) = .int n := by
              unfold simplifier_aux_mul
              split <;> injections
            simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              have : simplifier_aux_mul (.int n) (.int m) = .int (n * m) := by
                unfold simplifier_aux_mul
                rw [eq_int, B.Term.int.injEq] at eq0 eq1
                rename_i eq0' eq1' eq_int' _ _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                simp only
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.some_inj]
              congr <;> first | rw [overloadBinOp_Int.const_folding.mul] | apply proof_irrel_heq
            ¬∑ push_neg at eq_int
              have : simplifier_aux_mul (.int n) (simplifier y) = .int n *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                rename_i eq0' eq1' eq_int' _
                rw [eq_int', B.Term.int.injEq] at eq0' eq1'
                split <;> injections
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_some, y_ih, Option.bind_some]
      ¬∑ by_cases eq0 : simplifier y = .int 0
        ¬∑ simp_rw [eq0] at y_ih ‚ä¢
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
          injection y_ih
          subst Y

          simp [simplifier_aux_mul]
          simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj]
          congr <;> first | rw [overloadBinOp_Int.mul_zero] | apply proof_irrel_heq
        ¬∑ by_cases eq1 : simplifier y = .int 1
          ¬∑ simp_rw [eq1] at y_ih ‚ä¢
            simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
            injection y_ih
            subst Y

            have : simplifier_aux_mul (simplifier S.max) (.int 1) = simplifier S.max := by
              unfold simplifier_aux_mul
              split <;> (injections; try first | contradiction | rfl)
            simp_rw [this, x_ih, Option.some_inj]
            congr <;> first | rw [overloadBinOp_Int.mul_one] | apply proof_irrel_heq
          ¬∑ by_cases eq_int : ‚àÉ m, simplifier y = .int m
            ¬∑ obtain ‚ü®m, eq_int‚ü© := eq_int
              simp_rw [eq_int] at y_ih ‚ä¢
              simp_rw [Term.abstract, denote, Option.pure_def, Option.some_inj] at y_ih
              injection y_ih
              subst Y

              by_cases eq_mul : ‚àÉ u k, simplifier S.max = u *·¥Æ .int k
              ¬∑ obtain ‚ü®u, k, eq_mul‚ü© := eq_mul
                have typ_ := eq_mul ‚ñ∏ Typing.simplifier typ_x
                obtain ‚ü®-, typ_u, -‚ü© := Typing.mulE typ_
                simp_rw [eq_mul, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at x_ih
                obtain ‚ü®U, _, hU, den_u, eq‚ü© := x_ih
                obtain ‚ü®‚ü© := denote_welltyped_eq
                  ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
                  WFTC.of_abstract, _,
                  Typing.of_abstract (fun v hv => by
                    have : v ‚àà fv (simplifier S.max) := by
                      rw [eq_mul, fv, List.mem_append]
                      left
                      exact hv
                    apply ht
                    rw [fv, List.mem_append]
                    left
                    exact fv_simplifier wf_t.1 this
                  ) typ_u‚ü©
                  den_u

                dsimp at eq
                rw [Option.some_inj] at eq
                injection eq
                subst X

                have : simplifier_aux_mul (simplifier S.max) (.int m) = u *·¥Æ .int (k * m) := by
                  rw [eq_mul, simplifier_aux_mul] <;>
                  ¬∑ rintro rfl
                    contradiction
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, den_u, Option.bind_some, Option.some_inj]
                congr 1
                ¬∑ conv =>
                    enter [1,3]
                    apply overloadBinOp_Int.const_folding.mul k m
                  rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                ¬∑ congr 1
                  ¬∑ funext
                    conv =>
                      enter [1,2,3]
                      apply overloadBinOp_Int.const_folding.mul k m
                    rw [overloadBinOp_Int.mul_assoc hU (mem_ofInt_Int k) hY]
                  ¬∑ apply proof_irrel_heq
              ¬∑ push_neg at eq_mul
                have : simplifier_aux_mul (simplifier S.max) (B.Term.int m) = simplifier S.max *·¥Æ .int m := by
                  unfold simplifier_aux_mul
                  split <;> (injections; try first | contradiction | (subst_vars; contradiction) | rfl)
                simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some]
            ¬∑ have : simplifier_aux_mul (simplifier S.max) (simplifier y) = simplifier S.max *·¥Æ simplifier y := by
                unfold simplifier_aux_mul
                split <;> (injections; try first | contradiction | rfl)
              simp_rw [this, Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, x_ih, Option.bind_some, y_ih, Option.bind_some]

theorem simplifier_partial_correct.mul.{u_1} (x y : B.Term)
  (x_ih :
    ‚àÄ {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} (ht : ‚àÄ v ‚àà fv x, (¬´Œî¬ª v).isSome = true) (wf_t : x.WF) {Œì : B.TypeContext} {œÑ : BType},
      Œì ‚ä¢ x : œÑ ‚Üí
        ‚àÄ {T : ZFSet.{u_1}} {hTœÑ : T ‚àà œÑ.toZFSet},
          ‚ü¶x.abstract ¬´Œî¬ª ht‚üß·¥Æ = some ‚ü®T, ‚ü®œÑ, hTœÑ‚ü©‚ü© ‚Üí ‚ü¶(simplifier x).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ = some ‚ü®T, ‚ü®œÑ, hTœÑ‚ü©‚ü©)
  (y_ih :
    ‚àÄ {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} (ht : ‚àÄ v ‚àà fv y, (¬´Œî¬ª v).isSome = true) (wf_t : y.WF) {Œì : B.TypeContext} {œÑ : BType},
      Œì ‚ä¢ y : œÑ ‚Üí
        ‚àÄ {T : ZFSet.{u_1}} {hTœÑ : T ‚àà œÑ.toZFSet},
          ‚ü¶y.abstract ¬´Œî¬ª ht‚üß·¥Æ = some ‚ü®T, ‚ü®œÑ, hTœÑ‚ü©‚ü© ‚Üí ‚ü¶(simplifier y).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ = some ‚ü®T, ‚ü®œÑ, hTœÑ‚ü©‚ü©)
  {¬´Œî¬ª : ùí± ‚Üí Option B.Dom} (ht : ‚àÄ v ‚àà fv (x *·¥Æ y), (¬´Œî¬ª v).isSome = true) (wf_t : (x *·¥Æ y).WF) {Œì : B.TypeContext}
  {œÑ : BType} (typ_t : Œì ‚ä¢ x *·¥Æ y : œÑ) {T : ZFSet.{u_1}} {hTœÑ : T ‚àà œÑ.toZFSet}
  (den_t : ‚ü¶(x *·¥Æ y).abstract ¬´Œî¬ª ht‚üß·¥Æ = some ‚ü®T, ‚ü®œÑ, hTœÑ‚ü©‚ü©) :
  ‚ü¶(simplifier (x *·¥Æ y)).abstract ¬´Œî¬ª (isSome_fv_simplifier_of_fv_isSome wf_t ht)‚üß·¥Æ = some ‚ü®T, ‚ü®œÑ, hTœÑ‚ü©‚ü© := by
  simp_rw [Term.abstract, denote, Option.pure_def, Option.bind_eq_bind, Option.bind_eq_some_iff, PSigma.exists] at den_t

  obtain ‚ü®rfl, typ_x, typ_y‚ü© := Typing.mulE typ_t

  obtain ‚ü®X, œÑX, hX, den_x, eq‚ü© := den_t
  obtain rfl := denote_welltyped_eq
    ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
    WFTC.of_abstract, _,
    Typing.of_abstract (fun v hv => by apply ht; rw [fv, List.mem_append]; left; exact hv) typ_x‚ü©
    den_x

  simp_rw [Option.bind_eq_some_iff, PSigma.exists] at eq
  obtain ‚ü®Y, œÑY, hY, den_y, eq‚ü© := eq
  obtain rfl := denote_welltyped_eq
    ‚ü®Œì.abstract (¬´Œî¬ª := ¬´Œî¬ª),
    WFTC.of_abstract, _,
    Typing.of_abstract (fun v hv => by apply ht; rw [fv, List.mem_append]; right; exact hv) typ_y‚ü©
    den_y
  rw [Option.some_inj] at eq
  injection eq
  subst T

  specialize x_ih _ wf_t.1 typ_x den_x
  specialize y_ih _ wf_t.2 typ_y den_y

  -- all assumptions have been used

  cases x with
  | var v =>
    exact mul.var typ_y ht wf_t typ_t hX den_x hY den_y den_x y_ih
  | int n =>
    exact mul.int typ_y ht wf_t typ_t typ_x hX den_x hY den_y den_x y_ih
  | add a b =>
    exact mul.add ht wf_t typ_x hX den_x hY den_y x_ih y_ih
  | sub a b =>
    exact mul.sub ht wf_t typ_x hX den_x hY den_y x_ih y_ih
  | mul a b =>
    exact mul.mul ht wf_t typ_x hX den_x hY den_y x_ih y_ih
  | card S =>
    exact mul.card ht wf_t typ_x hX den_x hY den_y x_ih y_ih
  | app f x =>
    exact mul.app ht wf_t typ_x hX den_x hY den_y x_ih y_ih
  | min S =>
    exact mul.min ht wf_t typ_x hX den_x hY den_y x_ih y_ih
  | max S =>
    exact mul.max ht wf_t typ_x hX den_x hY den_y x_ih y_ih
  | bool | maplet | le | and | not | eq | ¬´‚Ñ§¬ª | ùîπ | mem | collect | pow | cprod | union | inter | lambda | pfun | all =>
    nomatch typ_t
